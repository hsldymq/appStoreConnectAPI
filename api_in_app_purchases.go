/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// InAppPurchasesApiService InAppPurchasesApi service
type InAppPurchasesApiService service

type ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchaseAppStoreReviewScreenshots *[]string
	fieldsInAppPurchases *[]string
	include *[]string
}

// the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
func (r ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest) FieldsInAppPurchaseAppStoreReviewScreenshots(fieldsInAppPurchaseAppStoreReviewScreenshots []string) ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsInAppPurchaseAppStoreReviewScreenshots = &fieldsInAppPurchaseAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest) Include(include []string) ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest) Execute() (*InAppPurchaseAppStoreReviewScreenshotResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesAppStoreReviewScreenshotGetToOneRelatedExecute(r)
}

/*
InAppPurchasesAppStoreReviewScreenshotGetToOneRelated Method for InAppPurchasesAppStoreReviewScreenshotGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesAppStoreReviewScreenshotGetToOneRelated(ctx context.Context, id string) ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest {
	return ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseAppStoreReviewScreenshotResponse
func (a *InAppPurchasesApiService) InAppPurchasesAppStoreReviewScreenshotGetToOneRelatedExecute(r ApiInAppPurchasesAppStoreReviewScreenshotGetToOneRelatedRequest) (*InAppPurchaseAppStoreReviewScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseAppStoreReviewScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesAppStoreReviewScreenshotGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/appStoreReviewScreenshot"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchaseAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAppStoreReviewScreenshots]", r.fieldsInAppPurchaseAppStoreReviewScreenshots, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesContentGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchases *[]string
	fieldsInAppPurchaseContents *[]string
	include *[]string
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesContentGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesContentGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchaseContents
func (r ApiInAppPurchasesContentGetToOneRelatedRequest) FieldsInAppPurchaseContents(fieldsInAppPurchaseContents []string) ApiInAppPurchasesContentGetToOneRelatedRequest {
	r.fieldsInAppPurchaseContents = &fieldsInAppPurchaseContents
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesContentGetToOneRelatedRequest) Include(include []string) ApiInAppPurchasesContentGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesContentGetToOneRelatedRequest) Execute() (*InAppPurchaseContentResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesContentGetToOneRelatedExecute(r)
}

/*
InAppPurchasesContentGetToOneRelated Method for InAppPurchasesContentGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesContentGetToOneRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesContentGetToOneRelated(ctx context.Context, id string) ApiInAppPurchasesContentGetToOneRelatedRequest {
	return ApiInAppPurchasesContentGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseContentResponse
func (a *InAppPurchasesApiService) InAppPurchasesContentGetToOneRelatedExecute(r ApiInAppPurchasesContentGetToOneRelatedRequest) (*InAppPurchaseContentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseContentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesContentGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsInAppPurchaseContents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseContents]", r.fieldsInAppPurchaseContents, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesCreateInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	inAppPurchaseV2CreateRequest *InAppPurchaseV2CreateRequest
}

// InAppPurchase representation
func (r ApiInAppPurchasesCreateInstanceRequest) InAppPurchaseV2CreateRequest(inAppPurchaseV2CreateRequest InAppPurchaseV2CreateRequest) ApiInAppPurchasesCreateInstanceRequest {
	r.inAppPurchaseV2CreateRequest = &inAppPurchaseV2CreateRequest
	return r
}

func (r ApiInAppPurchasesCreateInstanceRequest) Execute() (*InAppPurchaseV2Response, *http.Response, error) {
	return r.ApiService.InAppPurchasesCreateInstanceExecute(r)
}

/*
InAppPurchasesCreateInstance Method for InAppPurchasesCreateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInAppPurchasesCreateInstanceRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesCreateInstance(ctx context.Context) ApiInAppPurchasesCreateInstanceRequest {
	return ApiInAppPurchasesCreateInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InAppPurchaseV2Response
func (a *InAppPurchasesApiService) InAppPurchasesCreateInstanceExecute(r ApiInAppPurchasesCreateInstanceRequest) (*InAppPurchaseV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesCreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inAppPurchaseV2CreateRequest == nil {
		return localVarReturnValue, nil, reportError("inAppPurchaseV2CreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inAppPurchaseV2CreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesDeleteInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
}

func (r ApiInAppPurchasesDeleteInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.InAppPurchasesDeleteInstanceExecute(r)
}

/*
InAppPurchasesDeleteInstance Method for InAppPurchasesDeleteInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesDeleteInstanceRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesDeleteInstance(ctx context.Context, id string) ApiInAppPurchasesDeleteInstanceRequest {
	return ApiInAppPurchasesDeleteInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *InAppPurchasesApiService) InAppPurchasesDeleteInstanceExecute(r ApiInAppPurchasesDeleteInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesDeleteInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInAppPurchasesGetInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchases *[]string
	include *[]string
	limitApps *int32
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesGetInstanceRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesGetInstanceRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesGetInstanceRequest) Include(include []string) ApiInAppPurchasesGetInstanceRequest {
	r.include = &include
	return r
}

// maximum number of related apps returned (when they are included)
func (r ApiInAppPurchasesGetInstanceRequest) LimitApps(limitApps int32) ApiInAppPurchasesGetInstanceRequest {
	r.limitApps = &limitApps
	return r
}

func (r ApiInAppPurchasesGetInstanceRequest) Execute() (*InAppPurchaseResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesGetInstanceExecute(r)
}

/*
InAppPurchasesGetInstance Method for InAppPurchasesGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesGetInstanceRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesGetInstance(ctx context.Context, id string) ApiInAppPurchasesGetInstanceRequest {
	return ApiInAppPurchasesGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseResponse
func (a *InAppPurchasesApiService) InAppPurchasesGetInstanceExecute(r ApiInAppPurchasesGetInstanceRequest) (*InAppPurchaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.limitApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[apps]", r.limitApps, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesGetInstance_0Request struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchases *[]string
	include *[]string
	fieldsInAppPurchaseAppStoreReviewScreenshots *[]string
	fieldsPromotedPurchases *[]string
	fieldsInAppPurchasePricePoints *[]string
	fieldsInAppPurchaseLocalizations *[]string
	fieldsInAppPurchasePriceSchedules *[]string
	fieldsInAppPurchaseContents *[]string
	limitInAppPurchaseLocalizations *int32
	limitPricePoints *int32
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesGetInstance_0Request) Include(include []string) ApiInAppPurchasesGetInstance_0Request {
	r.include = &include
	return r
}

// the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
func (r ApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchaseAppStoreReviewScreenshots(fieldsInAppPurchaseAppStoreReviewScreenshots []string) ApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchaseAppStoreReviewScreenshots = &fieldsInAppPurchaseAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiInAppPurchasesGetInstance_0Request) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiInAppPurchasesGetInstance_0Request {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchasePricePoints
func (r ApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchasePricePoints(fieldsInAppPurchasePricePoints []string) ApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchasePricePoints = &fieldsInAppPurchasePricePoints
	return r
}

// the fields to include for returned resources of type inAppPurchaseLocalizations
func (r ApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchaseLocalizations(fieldsInAppPurchaseLocalizations []string) ApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchaseLocalizations = &fieldsInAppPurchaseLocalizations
	return r
}

// the fields to include for returned resources of type inAppPurchasePriceSchedules
func (r ApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchasePriceSchedules(fieldsInAppPurchasePriceSchedules []string) ApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchasePriceSchedules = &fieldsInAppPurchasePriceSchedules
	return r
}

// the fields to include for returned resources of type inAppPurchaseContents
func (r ApiInAppPurchasesGetInstance_0Request) FieldsInAppPurchaseContents(fieldsInAppPurchaseContents []string) ApiInAppPurchasesGetInstance_0Request {
	r.fieldsInAppPurchaseContents = &fieldsInAppPurchaseContents
	return r
}

// maximum number of related inAppPurchaseLocalizations returned (when they are included)
func (r ApiInAppPurchasesGetInstance_0Request) LimitInAppPurchaseLocalizations(limitInAppPurchaseLocalizations int32) ApiInAppPurchasesGetInstance_0Request {
	r.limitInAppPurchaseLocalizations = &limitInAppPurchaseLocalizations
	return r
}

// maximum number of related pricePoints returned (when they are included)
func (r ApiInAppPurchasesGetInstance_0Request) LimitPricePoints(limitPricePoints int32) ApiInAppPurchasesGetInstance_0Request {
	r.limitPricePoints = &limitPricePoints
	return r
}

func (r ApiInAppPurchasesGetInstance_0Request) Execute() (*InAppPurchaseV2Response, *http.Response, error) {
	return r.ApiService.InAppPurchasesGetInstance_1Execute(r)
}

/*
InAppPurchasesGetInstance_0 Method for InAppPurchasesGetInstance_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesGetInstance_0Request
*/
func (a *InAppPurchasesApiService) InAppPurchasesGetInstance_1(ctx context.Context, id string) ApiInAppPurchasesGetInstance_0Request {
	return ApiInAppPurchasesGetInstance_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseV2Response
func (a *InAppPurchasesApiService) InAppPurchasesGetInstance_1Execute(r ApiInAppPurchasesGetInstance_0Request) (*InAppPurchaseV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesGetInstance_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	if r.fieldsInAppPurchaseAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAppStoreReviewScreenshots]", r.fieldsInAppPurchaseAppStoreReviewScreenshots, "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsInAppPurchasePricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePricePoints]", r.fieldsInAppPurchasePricePoints, "csv")
	}
	if r.fieldsInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseLocalizations]", r.fieldsInAppPurchaseLocalizations, "csv")
	}
	if r.fieldsInAppPurchasePriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePriceSchedules]", r.fieldsInAppPurchasePriceSchedules, "csv")
	}
	if r.fieldsInAppPurchaseContents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseContents]", r.fieldsInAppPurchaseContents, "csv")
	}
	if r.limitInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchaseLocalizations]", r.limitInAppPurchaseLocalizations, "")
	}
	if r.limitPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[pricePoints]", r.limitPricePoints, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchasePrices *[]string
	fieldsInAppPurchases *[]string
	fieldsInAppPurchasePriceSchedules *[]string
	fieldsTerritories *[]string
	limitManualPrices *int32
	limitAutomaticPrices *int32
	include *[]string
}

// the fields to include for returned resources of type inAppPurchasePrices
func (r ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) FieldsInAppPurchasePrices(fieldsInAppPurchasePrices []string) ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.fieldsInAppPurchasePrices = &fieldsInAppPurchasePrices
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchasePriceSchedules
func (r ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) FieldsInAppPurchasePriceSchedules(fieldsInAppPurchasePriceSchedules []string) ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.fieldsInAppPurchasePriceSchedules = &fieldsInAppPurchasePriceSchedules
	return r
}

// the fields to include for returned resources of type territories
func (r ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum number of related manualPrices returned (when they are included)
func (r ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) LimitManualPrices(limitManualPrices int32) ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.limitManualPrices = &limitManualPrices
	return r
}

// maximum number of related automaticPrices returned (when they are included)
func (r ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) LimitAutomaticPrices(limitAutomaticPrices int32) ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.limitAutomaticPrices = &limitAutomaticPrices
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) Include(include []string) ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) Execute() (*InAppPurchasePriceScheduleResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesIapPriceScheduleGetToOneRelatedExecute(r)
}

/*
InAppPurchasesIapPriceScheduleGetToOneRelated Method for InAppPurchasesIapPriceScheduleGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesIapPriceScheduleGetToOneRelated(ctx context.Context, id string) ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest {
	return ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchasePriceScheduleResponse
func (a *InAppPurchasesApiService) InAppPurchasesIapPriceScheduleGetToOneRelatedExecute(r ApiInAppPurchasesIapPriceScheduleGetToOneRelatedRequest) (*InAppPurchasePriceScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchasePriceScheduleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesIapPriceScheduleGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/iapPriceSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchasePrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePrices]", r.fieldsInAppPurchasePrices, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsInAppPurchasePriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePriceSchedules]", r.fieldsInAppPurchasePriceSchedules, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limitManualPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[manualPrices]", r.limitManualPrices, "")
	}
	if r.limitAutomaticPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[automaticPrices]", r.limitAutomaticPrices, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsInAppPurchaseLocalizations *[]string
	fieldsInAppPurchases *[]string
	limit *int32
	include *[]string
}

// the fields to include for returned resources of type inAppPurchaseLocalizations
func (r ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) FieldsInAppPurchaseLocalizations(fieldsInAppPurchaseLocalizations []string) ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.fieldsInAppPurchaseLocalizations = &fieldsInAppPurchaseLocalizations
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// maximum resources per page
func (r ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) Limit(limit int32) ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) Include(include []string) ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) Execute() (*InAppPurchaseLocalizationsResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedExecute(r)
}

/*
InAppPurchasesInAppPurchaseLocalizationsGetToManyRelated Method for InAppPurchasesInAppPurchaseLocalizationsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesInAppPurchaseLocalizationsGetToManyRelated(ctx context.Context, id string) ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest {
	return ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseLocalizationsResponse
func (a *InAppPurchasesApiService) InAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedExecute(r ApiInAppPurchasesInAppPurchaseLocalizationsGetToManyRelatedRequest) (*InAppPurchaseLocalizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesInAppPurchaseLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/inAppPurchaseLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseLocalizations]", r.fieldsInAppPurchaseLocalizations, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesPricePointsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	filterPriceTier *[]string
	filterTerritory *[]string
	fieldsInAppPurchasePricePoints *[]string
	fieldsTerritories *[]string
	limit *int32
	include *[]string
}

// filter by attribute &#39;priceTier&#39;
func (r ApiInAppPurchasesPricePointsGetToManyRelatedRequest) FilterPriceTier(filterPriceTier []string) ApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.filterPriceTier = &filterPriceTier
	return r
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiInAppPurchasesPricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type inAppPurchasePricePoints
func (r ApiInAppPurchasesPricePointsGetToManyRelatedRequest) FieldsInAppPurchasePricePoints(fieldsInAppPurchasePricePoints []string) ApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.fieldsInAppPurchasePricePoints = &fieldsInAppPurchasePricePoints
	return r
}

// the fields to include for returned resources of type territories
func (r ApiInAppPurchasesPricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r ApiInAppPurchasesPricePointsGetToManyRelatedRequest) Limit(limit int32) ApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesPricePointsGetToManyRelatedRequest) Include(include []string) ApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesPricePointsGetToManyRelatedRequest) Execute() (*InAppPurchasePricePointsResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesPricePointsGetToManyRelatedExecute(r)
}

/*
InAppPurchasesPricePointsGetToManyRelated Method for InAppPurchasesPricePointsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesPricePointsGetToManyRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesPricePointsGetToManyRelated(ctx context.Context, id string) ApiInAppPurchasesPricePointsGetToManyRelatedRequest {
	return ApiInAppPurchasesPricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchasePricePointsResponse
func (a *InAppPurchasesApiService) InAppPurchasesPricePointsGetToManyRelatedExecute(r ApiInAppPurchasesPricePointsGetToManyRelatedRequest) (*InAppPurchasePricePointsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchasePricePointsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesPricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/pricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPriceTier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[priceTier]", r.filterPriceTier, "csv")
	}
	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "csv")
	}
	if r.fieldsInAppPurchasePricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePricePoints]", r.fieldsInAppPurchasePricePoints, "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	fieldsPromotedPurchases *[]string
	fieldsSubscriptions *[]string
	fieldsInAppPurchases *[]string
	fieldsPromotedPurchaseImages *[]string
	limitPromotionImages *int32
	include *[]string
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type promotedPurchaseImages
func (r ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchaseImages(fieldsPromotedPurchaseImages []string) ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchaseImages = &fieldsPromotedPurchaseImages
	return r
}

// maximum number of related promotionImages returned (when they are included)
func (r ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) LimitPromotionImages(limitPromotionImages int32) ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.limitPromotionImages = &limitPromotionImages
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) Include(include []string) ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) Execute() (*PromotedPurchaseResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesPromotedPurchaseGetToOneRelatedExecute(r)
}

/*
InAppPurchasesPromotedPurchaseGetToOneRelated Method for InAppPurchasesPromotedPurchaseGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesPromotedPurchaseGetToOneRelated(ctx context.Context, id string) ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest {
	return ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PromotedPurchaseResponse
func (a *InAppPurchasesApiService) InAppPurchasesPromotedPurchaseGetToOneRelatedExecute(r ApiInAppPurchasesPromotedPurchaseGetToOneRelatedRequest) (*PromotedPurchaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromotedPurchaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesPromotedPurchaseGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/promotedPurchase"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "csv")
	}
	if r.fieldsPromotedPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchaseImages]", r.fieldsPromotedPurchaseImages, "csv")
	}
	if r.limitPromotionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionImages]", r.limitPromotionImages, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesUpdateInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesApiService
	id string
	inAppPurchaseV2UpdateRequest *InAppPurchaseV2UpdateRequest
}

// InAppPurchase representation
func (r ApiInAppPurchasesUpdateInstanceRequest) InAppPurchaseV2UpdateRequest(inAppPurchaseV2UpdateRequest InAppPurchaseV2UpdateRequest) ApiInAppPurchasesUpdateInstanceRequest {
	r.inAppPurchaseV2UpdateRequest = &inAppPurchaseV2UpdateRequest
	return r
}

func (r ApiInAppPurchasesUpdateInstanceRequest) Execute() (*InAppPurchaseV2Response, *http.Response, error) {
	return r.ApiService.InAppPurchasesUpdateInstanceExecute(r)
}

/*
InAppPurchasesUpdateInstance Method for InAppPurchasesUpdateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesUpdateInstanceRequest
*/
func (a *InAppPurchasesApiService) InAppPurchasesUpdateInstance(ctx context.Context, id string) ApiInAppPurchasesUpdateInstanceRequest {
	return ApiInAppPurchasesUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseV2Response
func (a *InAppPurchasesApiService) InAppPurchasesUpdateInstanceExecute(r ApiInAppPurchasesUpdateInstanceRequest) (*InAppPurchaseV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesApiService.InAppPurchasesUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inAppPurchaseV2UpdateRequest == nil {
		return localVarReturnValue, nil, reportError("inAppPurchaseV2UpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inAppPurchaseV2UpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
